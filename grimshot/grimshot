#!/bin/sh

## Grimshot: a helper for screenshots within sway
## Requirements:
##  - `grim`: screenshot utility for wayland
##  - `slurp`: to select an area
##  - `swaymsg`: to read properties of current window
##  - `wl-copy`: clipboard utility
##  - `jq`: json utility to parse swaymsg output
##  - `notify-send`: to show notifications
## Those are needed to be installed, if unsure, run `grimshot check`
##
## See `man 1 grimshot` or `grimshot usage` for further details.

# Override standard echo to avoid confusing errors if, for example, a user
# provides options like "-w -n" to the program.
echo() {
  printf '%b\n' "$*"
}

NOTIFY=no
CURSOR=
WAIT=no

getTargetDirectory() {
  if [ -z "${XDG_SCREENSHOTS_DIR+set}${XDG_PICTURES_DIR+set}" ]; then
    test -f "${XDG_CONFIG_HOME:-$HOME/.config}/user-dirs.dirs" &&
      . "${XDG_CONFIG_HOME:-$HOME/.config}/user-dirs.dirs"
  fi

  echo "${XDG_SCREENSHOTS_DIR:-${XDG_PICTURES_DIR:-$HOME}}"
}

parseArgs() {
  for arg; do
    shift
    case "$arg" in
    -n | --notify)
      NOTIFY=yes
      ;;
    -c | --cursor)
      CURSOR=yes
      ;;
    -w | --wait)
      WAIT="$1"
      shift
      if echo "$WAIT" | grep -q "[^0-9]"; then
        echo "invalid value for wait '$WAIT'" >&2
        exit 3
      fi
      ;;
    *)                   # Treat anything else as a positional argument
      set -- "$@" "$arg" # Re-append to arguments.
      ;;
    esac
  done

  ACTION=${1:-usage}
  SUBJECT=${2:-screen}
  if [ -n "$GRIMSHOT_FILENAME_FORMAT" ]; then
    FILENAME=$GRIMSHOT_FILENAME_FORMAT
  else
    FILENAME=$(date -Ins)
  fi
  FILE=${3:-$(getTargetDirectory)/$FILENAME.png}

}

printUsageMsg() {
  echo "Usage:"
  echo "  grimshot [--notify] [--cursor] [--wait N] (copy|save) [active|screen|output|area|window|anything] [FILE|-]"
  echo "  grimshot check"
  echo "  grimshot usage"
  echo ""
  echo "Commands:"
  echo "  copy: Copy the screenshot data into the clipboard."
  echo "  save: Save the screenshot to a regular file or '-' to pipe to STDOUT."
  echo "  savecopy: Save the screenshot to a regular file and copy the data into the clipboard."
  echo "  check: Verify if required tools are installed and exit."
  echo "  usage: Show this message and exit."
  echo ""
  echo "Targets:"
  echo "  active: Currently active window."
  echo "  screen: All visible outputs."
  echo "  output: Currently active output."
  echo "  area: Manually select a region."
  echo "  window: Manually select a window."
  echo "  anything: Manually select an area, window, or output."
  exit
}

notify() {
  notify-send -t 3000 -a grimshot "$@"
}

notifyOk() {
  notify_disabled='[ "$NOTIFY" = "no" ]'

  if eval $notify_disabled; then
    return
  fi

  TITLE=${2:-"Screenshot"}
  MESSAGE=${1:-"OK"}

  if [ "$ACTION" = "save" ] || [ "$ACTION" = "savecopy" ]; then
    notify "$TITLE" "$MESSAGE" -i "$FILE"
  else
    notify "$TITLE" "$MESSAGE"
  fi
}

notifyError() {
  TITLE=${2:-"Screenshot"}
  errorMssg=$1
  MESSAGE=${errorMssg:-"Error taking screenshot with grim"}

  if [ "$NOTIFY" = "yes" ]; then
    notify "$TITLE" "$MESSAGE" -u critical
  else
    echo "$errorMssg"
  fi
}

die() {
  MSG=${1:-Bye}
  notifyError "Error: $MSG"
  exit 2
}

check() {
  COMMAND=$1

  if command -v "$COMMAND" > /dev/null 2>&1; then
    RESULT="OK"
  else
    RESULT="NOT FOUND"
  fi

  echo "   $COMMAND: $RESULT"
}

takeScreenshot() {
  FILE=$1
  GEOM=$2
  OUTPUT=$3

  if [ -n "$OUTPUT" ]; then
    grim ${CURSOR:+-c} -o "$OUTPUT" "$FILE" || die "Unable to invoke grim"
  elif [ -z "$GEOM" ]; then
    grim ${CURSOR:+-c} "$FILE" || die "Unable to invoke grim"
  else
    grim ${CURSOR:+-c} -g "$GEOM" "$FILE" || die "Unable to invoke grim"
  fi
}
checkRequiredTools() {
  echo "Checking if required tools are installed. If something is missing, install it to your system and make it available in PATH..."
  check grim
  check slurp
  check swaymsg
  check wl-copy
  check jq
  check notify-send
  exit
}

selectArea() {
  GEOM=$(slurp -d)
  [ -z "$GEOM" ] && exit 1
  WHAT="Area"
}

selectActiveWindow() {
  FOCUSED=$(swaymsg -t get_tree | jq -r 'recurse(.nodes[]?, .floating_nodes[]?) | select(.focused)')
  GEOM=$(echo "$FOCUSED" | jq -r '.rect | "\(.x),\(.y) \(.width)x\(.height)"')
  APP_ID=$(echo "$FOCUSED" | jq -r '.app_id')
  WHAT="$APP_ID window"
}

selectScreen() {
  GEOM=""
  WHAT="Screen"
}

selectOutput() {
  GEOM=""
  OUTPUT=$(swaymsg -t get_outputs | jq -r '.[] | select(.focused)' | jq -r '.name')
  WHAT="$OUTPUT"
}

selectWindow() {
  GEOM=$(swaymsg -t get_tree | jq -r '.. | select(.pid? and .visible?) | .rect | "\(.x),\(.y) \(.width)x\(.height)"' | slurp -r)
  [ -z "$GEOM" ] && exit 1
  WHAT="Window"
}

selectAnything() {
  GEOM=$(swaymsg -t get_tree | jq -r '.. | select(.pid? and .visible?) | .rect | "\(.x),\(.y) \(.width)x\(.height)"' | slurp -o)
  [ -z "$GEOM" ] && exit 1
  WHAT="Selection"
}
handleSaveCopy() {
  wl-copy --type image/png <"$FILE" || die "Clipboard error"
  MESSAGE="$MESSAGE and clipboard"
}

handleScreenshotSuccess() {
  TITLE="Screenshot of $SUBJECT"
  MESSAGE=$(basename "$FILE")
  [ "$ACTION" = "savecopy" ] && handleSaveCopy
  notifyOk "$MESSAGE" "$TITLE"
  echo "$FILE"
}

handleScreenshotFailure() {
  notifyError "Error taking screenshot with grim"
}

handleCopy() {
  takeScreenshot - "$GEOM" "$OUTPUT" | wl-copy --type image/png || die "Clipboard error"
  notifyOk "$WHAT copied to clipboard"
}

handleSave() {
  if takeScreenshot "$FILE" "$GEOM" "$OUTPUT"; then
    handleScreenshotSuccess
  else
    handleScreenshotFailure
  fi
}
handleUnknownSubject() {
  die "Unknown subject to take a screenshot from" "$SUBJECT"
}
handleScreenshot() {
  case "$ACTION" in
    check)
      checkRequiredTools ;;
    save | copy | savecopy | check) : ;; # nothing
    *)
      printUsageMsg ;;
  esac

  case "$SUBJECT" in
    area)
      selectArea ;;
    active)
      selectActiveWindow ;;
    screen)
      selectScreen ;;
    output)
      selectOutput ;;
    window)
      selectWindow ;;
    anything)
      selectAnything ;;
    *)
      handleUnknownSubject ;;
  esac

  [ "$WAIT" != "no" ] && sleep "$WAIT"

  if [ "$ACTION" = "copy" ]; then
    handleCopy
  else
    handleSave
  fi
}

parseArgs "$@"
handleScreenshot
